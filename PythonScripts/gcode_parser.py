#!/usr/bin/env python3
"""
G-code Parser for PrintVault 3D
Extracts metadata from G-code files (print time, filament usage, slicer info).
"""

import sys
import json
import re
import os
from typing import Optional, Dict, Any
from pathlib import Path


class GcodeParser:
    """Parser for extracting metadata from G-code files."""
    
    # Common slicer comment patterns
    PATTERNS = {
        # PrusaSlicer / SuperSlicer
        'prusa_time': re.compile(r';\s*estimated printing time.*?=\s*(.+)', re.IGNORECASE),
        'prusa_filament_used_mm': re.compile(r';\s*filament used \[mm\]\s*=\s*([\d.]+)', re.IGNORECASE),
        'prusa_filament_used_g': re.compile(r';\s*filament used \[g\]\s*=\s*([\d.]+)', re.IGNORECASE),
        'prusa_filament_used_m': re.compile(r';\s*filament used \[m\]\s*=\s*([\d.]+)', re.IGNORECASE),
        'prusa_layer_height': re.compile(r';\s*layer_height\s*=\s*([\d.]+)', re.IGNORECASE),
        'prusa_infill': re.compile(r';\s*fill_density\s*=\s*(\d+)%?', re.IGNORECASE),
        'prusa_nozzle_temp': re.compile(r';\s*temperature\s*=\s*(\d+)', re.IGNORECASE),
        'prusa_bed_temp': re.compile(r';\s*bed_temperature\s*=\s*(\d+)', re.IGNORECASE),
        
        # Cura
        'cura_time': re.compile(r';TIME:(\d+)', re.IGNORECASE),
        'cura_filament_used': re.compile(r';Filament used:\s*([\d.]+)m?', re.IGNORECASE),
        'cura_layer_height': re.compile(r';Layer height:\s*([\d.]+)', re.IGNORECASE),
        'cura_generated': re.compile(r';Generated with Cura_SteamEngine\s*([\d.]+)', re.IGNORECASE),
        
        # Simplify3D
        's3d_time': re.compile(r';\s*Build time:\s*(.+)', re.IGNORECASE),
        's3d_filament': re.compile(r';\s*Filament length:\s*([\d.]+)\s*mm', re.IGNORECASE),
        's3d_filament_weight': re.compile(r';\s*Plastic weight:\s*([\d.]+)\s*g', re.IGNORECASE),
        
        # Slic3r
        'slic3r_time': re.compile(r';\s*estimated printing time\s*=\s*(.+)', re.IGNORECASE),
        'slic3r_filament': re.compile(r';\s*filament used\s*=\s*([\d.]+)mm', re.IGNORECASE),
        
        # OrcaSlicer / BambuStudio
        'orca_time': re.compile(r';\s*total estimated time:\s*(.+)', re.IGNORECASE),
        'orca_filament_g': re.compile(r';\s*total filament used \[g\]\s*=\s*([\d.]+)', re.IGNORECASE),
        'orca_filament_m': re.compile(r';\s*total filament used \[m\]\s*=\s*([\d.]+)', re.IGNORECASE),
        
        # Generic patterns
        'generic_slicer': re.compile(r';\s*generated by\s+(.+)', re.IGNORECASE),
        'generic_slicer2': re.compile(r';\s*G-code generated by\s+(.+)', re.IGNORECASE),
    }
    
    def __init__(self, filepath: str):
        self.filepath = filepath
        self.metadata: Dict[str, Any] = {
            "success": False,
            "filepath": filepath,
            "error": None,
            "slicer_name": None,
            "slicer_version": None,
            "print_time_seconds": None,
            "print_time_formatted": None,
            "filament_used_mm": None,
            "filament_used_m": None,
            "filament_used_g": None,
            "layer_height": None,
            "infill_percentage": None,
            "nozzle_temp": None,
            "bed_temp": None,
        }
    
    def parse(self) -> Dict[str, Any]:
        """Parse the G-code file and extract metadata."""
        try:
            if not os.path.exists(self.filepath):
                self.metadata["error"] = f"File not found: {self.filepath}"
                return self.metadata
            
            # Read first 500 lines and last 100 lines (metadata usually at start/end)
            lines = []
            with open(self.filepath, 'r', encoding='utf-8', errors='ignore') as f:
                # Read first 500 lines
                for i, line in enumerate(f):
                    if i < 500:
                        lines.append(line)
                    else:
                        break
                
                # Read last 100 lines
                f.seek(0, 2)  # Go to end
                file_size = f.tell()
                
                # Estimate position for last 100 lines
                if file_size > 10000:
                    f.seek(max(0, file_size - 10000))
                    f.readline()  # Skip partial line
                    lines.extend(f.readlines()[-100:])
            
            # Process all lines
            for line in lines:
                self._parse_line(line.strip())
            
            # Calculate derived values
            self._calculate_derived_values()
            
            self.metadata["success"] = True
            
        except Exception as e:
            self.metadata["error"] = str(e)
            self.metadata["success"] = False
        
        return self.metadata
    
    def _parse_line(self, line: str):
        """Parse a single line for metadata."""
        if not line.startswith(';'):
            return
        
        # Check for slicer identification
        if self.metadata["slicer_name"] is None:
            for pattern_name in ['generic_slicer', 'generic_slicer2', 'cura_generated']:
                match = self.PATTERNS[pattern_name].search(line)
                if match:
                    slicer_info = match.group(1).strip()
                    self.metadata["slicer_name"] = slicer_info
                    # Try to extract version
                    version_match = re.search(r'([\d.]+)', slicer_info)
                    if version_match:
                        self.metadata["slicer_version"] = version_match.group(1)
                    break
        
        # Check for print time
        if self.metadata["print_time_seconds"] is None:
            # PrusaSlicer format: "1h 30m 45s" or "1d 2h 30m"
            for pattern_name in ['prusa_time', 'slic3r_time', 'orca_time', 's3d_time']:
                match = self.PATTERNS[pattern_name].search(line)
                if match:
                    time_str = match.group(1).strip()
                    self.metadata["print_time_formatted"] = time_str
                    self.metadata["print_time_seconds"] = self._parse_time_string(time_str)
                    break
            
            # Cura format: seconds as integer
            match = self.PATTERNS['cura_time'].search(line)
            if match:
                seconds = int(match.group(1))
                self.metadata["print_time_seconds"] = seconds
                self.metadata["print_time_formatted"] = self._format_seconds(seconds)
        
        # Check for filament usage
        if self.metadata["filament_used_g"] is None:
            for pattern_name in ['prusa_filament_used_g', 's3d_filament_weight', 'orca_filament_g']:
                match = self.PATTERNS[pattern_name].search(line)
                if match:
                    self.metadata["filament_used_g"] = float(match.group(1))
                    break
        
        if self.metadata["filament_used_m"] is None:
            for pattern_name in ['prusa_filament_used_m', 'orca_filament_m', 'cura_filament_used']:
                match = self.PATTERNS[pattern_name].search(line)
                if match:
                    value = float(match.group(1))
                    # Cura might give it in meters directly
                    self.metadata["filament_used_m"] = value
                    break
        
        if self.metadata["filament_used_mm"] is None:
            for pattern_name in ['prusa_filament_used_mm', 'slic3r_filament', 's3d_filament']:
                match = self.PATTERNS[pattern_name].search(line)
                if match:
                    self.metadata["filament_used_mm"] = float(match.group(1))
                    break
        
        # Check for layer height
        if self.metadata["layer_height"] is None:
            for pattern_name in ['prusa_layer_height', 'cura_layer_height']:
                match = self.PATTERNS[pattern_name].search(line)
                if match:
                    self.metadata["layer_height"] = float(match.group(1))
                    break
        
        # Check for infill
        if self.metadata["infill_percentage"] is None:
            match = self.PATTERNS['prusa_infill'].search(line)
            if match:
                self.metadata["infill_percentage"] = int(match.group(1))
        
        # Check for temperatures
        if self.metadata["nozzle_temp"] is None:
            match = self.PATTERNS['prusa_nozzle_temp'].search(line)
            if match:
                self.metadata["nozzle_temp"] = int(match.group(1))
        
        if self.metadata["bed_temp"] is None:
            match = self.PATTERNS['prusa_bed_temp'].search(line)
            if match:
                self.metadata["bed_temp"] = int(match.group(1))
    
    def _parse_time_string(self, time_str: str) -> Optional[int]:
        """Parse time string like '1h 30m 45s' or '1d 2h 30m' to seconds."""
        try:
            total_seconds = 0
            
            # Match days
            days_match = re.search(r'(\d+)\s*d', time_str, re.IGNORECASE)
            if days_match:
                total_seconds += int(days_match.group(1)) * 86400
            
            # Match hours
            hours_match = re.search(r'(\d+)\s*h', time_str, re.IGNORECASE)
            if hours_match:
                total_seconds += int(hours_match.group(1)) * 3600
            
            # Match minutes
            mins_match = re.search(r'(\d+)\s*m(?:in)?', time_str, re.IGNORECASE)
            if mins_match:
                total_seconds += int(mins_match.group(1)) * 60
            
            # Match seconds
            secs_match = re.search(r'(\d+)\s*s', time_str, re.IGNORECASE)
            if secs_match:
                total_seconds += int(secs_match.group(1))
            
            return total_seconds if total_seconds > 0 else None
            
        except Exception:
            return None
    
    def _format_seconds(self, seconds: int) -> str:
        """Format seconds as human-readable string."""
        days = seconds // 86400
        hours = (seconds % 86400) // 3600
        minutes = (seconds % 3600) // 60
        secs = seconds % 60
        
        parts = []
        if days > 0:
            parts.append(f"{days}d")
        if hours > 0:
            parts.append(f"{hours}h")
        if minutes > 0:
            parts.append(f"{minutes}m")
        if secs > 0 or not parts:
            parts.append(f"{secs}s")
        
        return " ".join(parts)
    
    def _calculate_derived_values(self):
        """Calculate derived values from parsed data."""
        # Convert mm to m if we have mm but not m
        if self.metadata["filament_used_m"] is None and self.metadata["filament_used_mm"] is not None:
            self.metadata["filament_used_m"] = self.metadata["filament_used_mm"] / 1000
        
        # Estimate weight if we have length but not weight (assuming 1.75mm PLA ~2.98g/m)
        if self.metadata["filament_used_g"] is None and self.metadata["filament_used_m"] is not None:
            # Rough estimate for 1.75mm PLA
            self.metadata["filament_used_g"] = round(self.metadata["filament_used_m"] * 2.98, 2)


def main():
    """Main entry point for command-line usage."""
    if len(sys.argv) < 2:
        print(json.dumps({
            "success": False,
            "error": "Usage: python gcode_parser.py <gcode_path>"
        }))
        sys.exit(1)
    
    gcode_path = sys.argv[1]
    
    parser = GcodeParser(gcode_path)
    result = parser.parse()
    
    print(json.dumps(result, indent=2))
    sys.exit(0 if result["success"] else 1)


if __name__ == "__main__":
    main()

